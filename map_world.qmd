---
title: "Sentencing mapping"
format: html
execute:
  echo: true
  warning: false
  error: false
---

This Quarto document provides an R workflow that:

- reads `data.xlsx` and finds the column containing country names (case-insensitive);
- builds a single working spatial dataset (world + UK subdivisions);
- marks rows as `covered` when the spreadsheet contains a `Y/Yes/1` value in a coverage column;
- leaves placeholders for additional variables (e.g. `legal_system_type`) so someone can add them later without changing the geometry code;
- plots the selected countries directly to the R plotting pane (no file outputs by default).

Notes:
- If `rmapshaper` is installed the document will use `rmapshaper::ms_simplify()` for faster, topology-preserving simplification; otherwise it falls back to `sf::st_simplify()`.

```{r setup}
library(readxl)
library(sf)
library(ggplot2)

# Paths (edit only these)
input_path <- "data.xlsx"
world_shp <- "World_Countries_Generalized.shp"
uk_shp <- "UK/CTRY_DEC_2022_UK_BFC_v2_c.shp"

# (No caching: the document always rebuilds `map_data` from the raw shapefiles.)

# Small helper: find country column case-insensitively
find_country_col <- function(df) {
  cand <- names(df)[tolower(names(df)) == "country"]
  if (length(cand) == 0) stop("Spreadsheet must have a column named 'Country' (case-insensitive)")
  cand[1]
}

``` 

## Read data and determine covered countries

```{r read-data}
# read spreadsheet
df <- read_excel(input_path)
country_col <- find_country_col(df)

# optional coverage column (search header containing 'cover')
covered_col <- names(df)[grepl("cover", tolower(names(df)))]
covered_names <- character(0)
if (length(covered_col) > 0) {
  covered_col <- covered_col[1]
  cov_vals <- tolower(as.character(df[[covered_col]]))
  covered_idx <- which(cov_vals %in% c("y","yes","true","1"))
  covered_names <- unique(tolower(trimws(as.character(df[[country_col]]))[covered_idx]))
}

cat("Found country column:", country_col, "\n")
cat("Number of covered names:", length(covered_names), "\n")

# Normalise common name variants to the shapefile naming where necessary (esp. turkey)
# Add entries here as needed: spreadsheet -> shapefile name
if (length(covered_names) > 0) {
  alias_map <- c(
    "turkey" = "turkiye"
  )
  covered_names <- sapply(covered_names, function(x) {
    if (x %in% names(alias_map)) alias_map[[x]] else x
  }, USE.NAMES = FALSE)
  covered_names <- unique(covered_names)
  message("Applied name alias mapping for common variants (e.g. turkey -> turkiye)")
}
``` 

## Build working spatial dataset

```{r build-working}
# This document now builds the working spatial dataset directly from the
# raw shapefiles. The combined object is called `map_data` and is kept
# deliberately simple: one `name` column, geometry, a `source` flag,
# placeholders for extra attributes, and a logical `covered` column.
# Keep this code as is. 

world0 <- st_read(world_shp, quiet = TRUE)
uk0 <- st_read(uk_shp, quiet = TRUE)

# choose sensible name fields
wname <- intersect(c("COUNTRY","country","NAME","name","NAME_LONG","name_long","admin","ADMIN"), names(world0))[1]
if (is.na(wname)) stop("No name field found in world shapefile")
uname <- if ("CTRY22NM" %in% names(uk0)) "CTRY22NM" else intersect(names(uk0), c("name","NAME","country","COUNTRY"))[1]
if (is.na(uname)) stop("No name field found in UK shapefile")

# keep only name + geometry to preserve simplicity
world <- world0[, wname, drop = FALSE]
names(world)[1] <- "name"
world$name <- tolower(trimws(as.character(world$name)))
world$source <- "world"

uk <- uk0[, uname, drop = FALSE]
names(uk)[1] <- "name"
uk$name <- tolower(trimws(as.character(uk$name)))
uk$source <- "uk"

# ensure same CRS
if (st_crs(world) != st_crs(uk)) uk <- st_transform(uk, st_crs(world))

# remove aggregate United Kingdom from world if present
world <- world[!world$name %in% c("united kingdom","unitedkingdom","united kingdom of great britain and northern ireland"), ]

# combine into a single working dataset named `map_data`
map_data <- rbind(world, uk)

# placeholders for easy attribute editing later (keeps structure similar to original data)
map_data$legal_system_type <- NA_character_
map_data$specialist_substance_use_courts <- NA_character_

# mark coverage from spreadsheet (covered_names computed earlier)
map_data$covered <- map_data$name %in% covered_names

message("Built working dataset: map_data (rows = ", nrow(map_data), ")")

``` 

```{r diagnostic-matching}
# Diagnostic: report any covered names from the spreadsheet that were not matched
# against the shapefile `map_data$name`. Helpful to spot spelling/standardisation issues.
covered_names <- sort(unique(covered_names))
matched <- intersect(map_data$name, covered_names)
unmatched <- setdiff(covered_names, map_data$name)
cat("Covered names (spreadsheet):", length(covered_names), "\n")
cat("Matched in shapefile :", length(matched), "\n")
cat("Unmatched           :", length(unmatched), "\n")
if (length(unmatched) > 0) {
  print(unmatched)
  # suggest closest matches by edit distance
  suggestions <- sapply(unmatched, function(u) {
    d <- utils::adist(u, map_data$name)
    map_data$name[which.min(d)]
  }, USE.NAMES = FALSE)
  suggestion_df <- data.frame(requested = unmatched, suggestion = suggestions, stringsAsFactors = FALSE)
  print(suggestion_df)
}
```

## Plot selected countries

```{r plot, fig.height=7, fig.width=11}
covered_count <- sum(map_data$covered, na.rm = TRUE)

# remove Antarctica (and similar polar features) which distorts the map
map_data_no_antar <- map_data[!grepl("antar", map_data$name), ]

# prepare readable labels
map_data_no_antar$label <- tools::toTitleCase(map_data_no_antar$name)

p <- ggplot() +
  geom_sf(data = map_data_no_antar, fill = "#f7f7f7", colour = "#dcdcdc", size = 0.08) +
  geom_sf(data = subset(map_data_no_antar, covered), fill = "#2b8cbe", colour = "#08306b", size = 0.28, alpha = 0.95) +
  labs(title = "Selected countries",
       subtitle = paste0("Highlighted: ", covered_count, " countries from spreadsheet")) +
  coord_sf(expand = FALSE) +
  theme_void() +
  theme(
    plot.title = element_text(size = 18, face = "bold", margin = margin(b = 6)),
    plot.subtitle = element_text(size = 11, margin = margin(b = 8)),
    plot.caption = element_text(size = 8, margin = margin(t = 8)),
    panel.background = element_rect(fill = "#eaf3ff", colour = NA),
    plot.background = element_rect(fill = "#ffffff", colour = NA),
    legend.position = "right"
  )

# Add labels for covered countries. 
covered_sf <- subset(map_data_no_antar, covered)
if (nrow(covered_sf) > 0) {
  pts <- st_point_on_surface(covered_sf)
  pts$label <- tools::toTitleCase(covered_sf$name)
  coords <- st_coordinates(pts)
  labdf <- data.frame(X = coords[,1], Y = coords[,2], label = pts$label, stringsAsFactors = FALSE)
  if (requireNamespace("ggrepel", quietly = TRUE)) {
    p <- p + ggrepel::geom_label_repel(data = labdf,
                                       aes(X, Y, label = label),
                                       size = 4.2,
                                       fontface = "bold",
                                       fill = "#ffffffee",
                                       colour = "#08306b",
                                       box.padding = 0.35,
                                       segment.size = 0.25,
                                       segment.colour = "#08306b",
                                       min.segment.length = 0,
                                       max.overlaps = 200)
  } else {
    p <- p + geom_label(data = labdf, aes(X, Y, label = label), size = 4.2, fontface = "bold", fill = "#ffffff", colour = "#08306b", label.r = unit(0.15, "lines"))
  }
}

print(p)
```

```{r plot-bw, fig.height=7, fig.width=11}
# Greyscale map (no title) â€” useful for print or monochrome displays
map_data_no_antar <- map_data[!grepl("antar", map_data$name), ]

p_bw <- ggplot() +
  geom_sf(data = map_data_no_antar, fill = "#f0f0f0", colour = "#d0d0d0", size = 0.08) +
  geom_sf(data = subset(map_data_no_antar, covered), fill = "#4b4b4b", colour = "#000000", size = 0.2, alpha = 0.95) +
  coord_sf(expand = FALSE) +
  theme_void() +
  theme(
    panel.background = element_rect(fill = "#ffffff", colour = NA),
    plot.background = element_rect(fill = "#ffffff", colour = NA),
    legend.position = "none"
  )

# Add labels (greyscale)
covered_sf <- subset(map_data_no_antar, covered)
if (nrow(covered_sf) > 0) {
  pts <- st_point_on_surface(covered_sf)
  pts$label <- tools::toTitleCase(covered_sf$name)
  coords <- st_coordinates(pts)
  labdf <- data.frame(X = coords[,1], Y = coords[,2], label = pts$label, stringsAsFactors = FALSE)
  if (requireNamespace("ggrepel", quietly = TRUE)) {
    p_bw <- p_bw + ggrepel::geom_label_repel(data = labdf, aes(X, Y, label = label),
                                            size = 3.8, fontface = "bold", colour = "#000000",
                                            fill = "#ffffffcc", box.padding = 0.25, segment.size = 0.22,
                                            segment.colour = "#444444", min.segment.length = 0, max.overlaps = 200)
  } else {
    p_bw <- p_bw + geom_label(data = labdf, aes(X, Y, label = label), size = 4, fontface = "bold", fill = "#ffffff", colour = "#000000", label.r = unit(0.15, "lines"))
  }
}

print(p_bw)
```

## Quick edit: add or edit variables

You can add or edit extra variables simply by editing `map_data` in R and saving a copy if you want to persist changes. Example:

```{r edit-example}
# Example: mark a few countries as having specialist courts and save a working copy
map_data$legal_system_type[map_data$name %in% c("singapore")] <- "common law"
map_data$specialist_substance_use_courts[map_data$name %in% c("singapore")] <- "yes"
```


